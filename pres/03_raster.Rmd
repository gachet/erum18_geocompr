---
title: "Tutorial: Geocomputation with R"
subtitle: "âš”<br>Geographic raster data in R"
author: "Jannes Muenchow, Robin Lovelace"
date: "ERUM Budapest, 2018-05-14"
output:
  xaringan::moon_reader:
    css: "raw/xaringan/my-theme.css"
    seal: true
    lib_dir: libs
    nature:
#      highlightStyle: dracula
      highlightLines: true
      ratio: '4:3'
      countIncrementalSlides: false
---

layout: true
background-image: url(raw/xaringan/img/r_geocomp_background.png)
background-size: cover

---
# Raster data in R

Remember: the geographic raster data model is used to represent continuous surfaces.
Rasters consist of a **header** and a **matrix** containing the actual values. 
Let's create a raster from scratch.
In R we use the **raster** package written by Robert J. Hijmans.
--

```{r, message=FALSE}
library("raster")
elev = raster(nrow = 6, ncol = 6, res = 0.5,
              xmn = -1.5, xmx = 1.5,
              ymn = -1.5, ymx = 1.5,
              vals = 1:36)
```

---

# Raster data in R

```{r}
elev
```

---

# Raster data in R

.pull-left[
```{r, eval=FALSE}
plot(elev)
```
]

--

.pull-right[
```{r, echo=FALSE}
plot(elev)
```
]
---

# Raster attribute subsetting
Since a raster is a matrix, subsetting follows the usual `i,j` conventions. Let's select the first and the last value.
--

```{r}
elev[1, 1]
elev[6, 6]
```
???
or using cell IDs:

```{r, eval=FALSE}
elev[1]
elev[36]
```
---

# Raster spatial operations - subsetting

using coordinates:
```{r}
extract(elev, data.frame(x = 0.75, y = 0.75))
```
--

using a SpatialObject (`SpatialPointsDataFrame`):
--

```{r, message=FALSE}
library("sf")
library("dplyr")
pt = st_point(c(0.75, 0.75)) %>%
  st_sfc %>%
  st_sf %>% 
  as(., "Spatial")
# use the SpatialObject for subsetting
elev[pt]
```
---

using another raster object:

.pull-left[
```{r}
clip = 
  raster(nrow = 3, ncol = 3, 
         res = 0.3, xmn = 0.6, 
         xmx = 1.5, ymn = -0.45, 
         ymx = 0.45, 
         vals = rep(1, 9))
elev[clip]
```
]

--
.pull-right[
```{r, echo=FALSE}
plot(elev, legend = FALSE)
plot(rasterToPolygons(clip), add = TRUE)
```
]

???
all raster values are returned when their midpoint is covered by the overlayed object
---

# Map algebra - local operations
You may use with raster datasets:

- algebraic operators such as `+`, `-`, `*`, `/`
- logical operators such as `>`, `>=`, `<`, `==`, `!`
- functions such as `abs`, `round`, `ceiling`, `floor`, `trunc`, `sqrt`, `log`, `log10`, `exp`, `cos`, `sin`, `max`,  `min`,  `range`,  `prod`,  `sum`,  `any`,  `all`.   
--

```{r, eval=FALSE}
elev + 1
elev^2
elev / 4
```
--

Cell-by-cell operations are also called local operations.
The calculation of the NDVI is one of the most popular examples.

???
The calculation of the normalized difference vegetation index (NDVI) is one of the most famous local, i.e. pixel-by-pixel, raster operations.
It ranges between - 1 and 1 with positive values indicating the presence of living plants (mostly > 0.2).
To calculate the NDVI, one uses the red and near-infrared bands of remotely sensed imagery (e.g. Landsat or Sentinel imagery) exploiting the fact that vegetation absorbs light heavily in the visible light spectrum, and especially in the red channel, while reflecting it in the near-infrared spectrum.
---

# Map algebra - focal operations
While local functions operate on one cell, though possibly from multiple layers, **focal** operations take into account a central cell and its neighbors.
The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors) but can take on any other (not necessarily rectangular) shape as defined by the user.
???
A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the the central cell, and moves on to the next central cell.
Other names for this operation are spatial filtering and convolution.

---

# Map algebra - focal operations
```{r, elev = FALSE}
r_focal = focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min)
``` 

<center>
<figure>
<img  src="img/04_focal_example.png" width = "100%", height = "100%"/>
</figure>
---

# Map algebra - zonal operations
zonal -> compute the mean elevation for different land use classes
---

# Map algebra - global operations
global -> summary statistiscs

---
# Geometric operations on raster data
---

# Intersecting geometry
If you want the intersecting geometry instead of the values, set the the `drop`-parameter to `FALSE`:
--

```{r}
elev[clip, drop = FALSE]
```

---

# Intersecting geometry
which in fact is the same as using `intersect()`:

```{r}
raster::intersect(elev, clip)
```
---
# Aggregation and disaggregation
Change the resolution of a raster:

.pull-left[
```{r, eval=FALSE}
elev_agg = 
  aggregate(elev, fact = 2,
            fun = mean)
```
Use `dissaggregate()` for increasing the spatial resolution of a raster
]

--

.pull-right[
```{r, echo=FALSE}
elev_agg = aggregate(elev, fact = 2, fun = mean)
par(mfrow = c(1, 2))
plot(elev)
plot(elev_agg)
```
]
---

# Reprojecting a raster
projectRaster

---

# Your turn